{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#introduction","title":"Introduction","text":"<p>The Aether software suite establishes and maintains the behaviour system for Living Architecture Testbeds.  It consists of four components which operate together to enable persistent, coordinated and controllable behaviour within the testbed:</p> <ul> <li>Microcontroller firmware (C++) within each ESP-32 Node Controller (NC) device within the system establishes a distributed means for elements to respond to influences</li> <li>A Node.js server (Javascript) to coordinate the distributed elements within the system and serve the browser-based control pages</li> <li>Browser-based software (Javascript) to create Graphical User Interface (GUI) elements for controlling behaviour logic and influences within the environment</li> <li>A realtime database (Firebase) to maintain the configuration of the system, its settings and its various user sessions and contexts</li> </ul> <p>Key functional principles used in the testbeds include</p> <ul> <li>Influence Engines:   Layered, spatialized algorithms that establish influence on elements of the system</li> <li>Reactor Cells:   Elements within a node-controller that respond to stimulus via coordinated time-based reaction profiles</li> <li>Subscription:   Means by which specific node controllers become aware of and sensitive to influences</li> </ul> <p>Because the system is distributed among various platforms, code is reused wherever possible.  To enable functional aspects of the browser-based GUI representations of node controllers, for example, some of the C++ code that the physical microcontrollers use is compiled into Web Assembly (WASM) modules that are integrated into the javascript running on these pages.  Similarly, the core of each Influence Engine is implemented once in C++ and then used as a WASM within the browser to visualize the effect of the influence engines.</p>"},{"location":"guide/","title":"Guides:","text":"<p>Guides provide step by step walkthroughs for:</p> <ol> <li>Setting up a new testbed</li> <li>Creating a new Influence Engine</li> </ol>"},{"location":"guide/influence_engine/","title":"Introduction to Influence Engines","text":"<ol> <li>Influence Engines are Algorithms</li> </ol> <p>At the heart of LASG\u2019s behaviour system is the concept of Influence Engines. An influence engine is a piece of software that algorithmically generates \u2018influences\u2019 on the various spatially distributed parts of the sculpture. For example, a simple influence engine might create waveforms that move through the sculpture by determining the amplitude of a wave at various physical locations in the space. A different Influence Engine might use particle dynamics to calculate the trajectory of virtual objects which influence elements within the sculpture. </p>"},{"location":"guide/influence_engine/design/","title":"Designing an Influence Engine","text":"<ol> <li>Inputs, outputs, parameters and events  </li> <li>Browser-based visualization and graphical interface  </li> <li>Third-party tool integration (eg. Max MSP)</li> </ol>"},{"location":"guide/influence_engine/documentation/","title":"Document your Influence Engine","text":""},{"location":"guide/influence_engine/events/","title":"Events","text":""},{"location":"guide/influence_engine/firmware/","title":"Firmware","text":""},{"location":"guide/influence_engine/firmware/#implement-an-influence-engine-in-cpp","title":"Implement an influence Engine in CPP","text":"<ol> <li> <p>Copy <code>TemplateEngine.h</code> to <code>AmbientWaves.h</code> and rename all the instances of TemplateEngine to AmbientWaves.</p> </li> <li> <p>Copy <code>TemplateEngine.cpp</code> to <code>AmbientWaves.cpp</code> and rename all instances of TemplateEngine to AmbientWaves</p> </li> <li> <p>Add the required header files needed, for ambient waves only <code>math.h</code> is needed <pre><code>#include \"math.h\"\n</code></pre></p> </li> <li> <p>Add the ambient waves paremeters to the class definition in <code>AmbientWaves.h</code>: <pre><code>  float velocity = 0.1;\n  float amplitude = 0.25;\n  float period = 0.2;\n  float angle = M_PI/2;\n</code></pre></p> </li> <li> <p>Register them in <code>populateTable</code> method of <code>AmbientWaves.cpp</code> so they can be sent over OSC and shown in the dashboard <pre><code>  tb.add(\"velocity\", &amp;velocity, {.min = 0, .max = 2, .step = 0.01});\n  tb.add(\"angle\", &amp;angle, {.min = 0, .max = 2 * M_PI, .step = 0.01});\n  tb.add(\"period\", &amp;period, {.min = 0, .max = 1, .step = 0.01});\n  tb.add(\"amplitude\", &amp;amplitude, {.min = 0, .max = 1, .step = 0.01});\n</code></pre></p> </li> <li> <p>The influence part of the influence engine is calculate in the <code>influenceOn</code> method</p> </li> </ol>"},{"location":"guide/influence_engine/firmware/#register-influence-engine-in-base-lasg-code","title":"Register Influence Engine in base LASG code","text":""},{"location":"guide/influence_engine/firmware/#compile-firmware","title":"Compile firmware","text":""},{"location":"guide/influence_engine/gui/","title":"GUI","text":"<ol> <li>Specify basic tools and components  </li> <li>Implement specific IE visualization     [ tbd ]</li> </ol>"},{"location":"guide/influence_engine/overview/","title":"Overview","text":"<p>An influence engine needs a name, for this guide the influence engine will be called Ambient Waves, and it will simply create an infinite moving sine wave of influence, with specific angle, period, amplitude and velocity (seen from plan view).  This wave will exert an influence proportional to the amplitude of the sine wave in any given location (offset so that its influence is read from 0.0-1.0).</p>"},{"location":"guide/influence_engine/setup/","title":"Setup","text":""},{"location":"guide/influence_engine/setup/#github","title":"Github","text":"<p>Ask for access to https://github.com/pbarch/testbed-v4 (from TODO) and clone it with <code>git clone  https://github.com/pbarch/testbed-v4</code></p>"},{"location":"guide/influence_engine/setup/#nodejs-npm","title":"Node.js &amp; NPM","text":"<p>Nodejs is used for running the server and firebase database  On windows or macos Install nodejs and npm from https://nodejs.org/en/download/prebuilt-installer if needed  Once node and npm are installed install dependencies with  <pre><code>cd Testbed_Server\nnpm install\n</code></pre></p>"},{"location":"guide/influence_engine/setup/#firebase","title":"Firebase","text":""},{"location":"guide/influence_engine/setup/#zig","title":"Zig","text":"<p>Zig is used for building the wasm modules and to write build scripts Download zig version 0.13.0 from https://ziglang.org/download/ and unzip it to <code>testbed-v4/NCv4_Firmware/zig</code>, the zig binary will be located at <code>zig/zig</code> bold</p>"},{"location":"guide/influence_engine/setup/#arduino","title":"Arduino","text":"<p>The arduino firmware can be built with the arduino ide installed from https://www.arduino.cc/en/software and it requires these plugins (TODO)  Alternatively the arduino cli is integrated with the zig build script and can be installed from https://arduino.github.io/arduino-cli/1.0/installation/ then can be used with <code>zig build arduino</code> or <code>zig build arduino -Dupload &lt;upload port&gt;</code></p>"},{"location":"guide/influence_engine/testing/","title":"Testing","text":""},{"location":"guide/influence_engine/wasm/","title":"WebAssembly","text":"<ol> <li> <p>Create &amp; compile WASM Influence Engine wrapper  </p> </li> <li> <p>Register the Influence Engine\u2019s wasm binary in the dashboard</p> </li> </ol>"},{"location":"guide/influence_engine/wasm/#compiling-a-wasm-influence-engine","title":"Compiling A WASM Influence Engine","text":"<p>To recompile an existing WASM Influence engine. Run <code>zig build</code> in the NCv4_Firmware directory. This will build all IE's in the zig.build config file and save the compiled WASMs to the Testbed_Server/public directory.</p> <p>To add a new IE to the zig build step, add a buildWasm() call to to the <code>pub fn build(b: *std.Build)</code> function. For example, the ambient waves build function looks like:</p> <pre><code>buildWasm(b, \"AmbientWaves\", &amp;.{\n    \"AmbientWaves.cpp\",\n    \"AmbientWavesWasm.cpp\",\n}, optimize);\n</code></pre>"},{"location":"guide/testbed_setup/testbed_setup/","title":"Testbed Setup","text":"<p>To create a new testbed, the following data needs to be provided:</p> <ol> <li> <p>Testbed Data: Testbed data describes the spatial locations, and metadata that describe the actuators, sensors &amp; node controllers that make up a testbed. This data is provided using the \"Living Architecture Systems Description\" (LASD) format.</p> </li> <li> <p>Testbed Image: The testbed image is the background image displayed in the Influence Engine dashboard.</p> </li> </ol>"},{"location":"guide/testbed_setup/testbed_setup/#1-authoring-testbed-data","title":"1) Authoring Testbed Data:","text":"<p>Testbed Data in the LASD format can be authored in the 3D modeling tools Blender or Rhino and exported using the LASD plugins (install information for LASD plugins can be found here). To export an</p> <p>To export Testbed Data directly from Blender to an Aether Database configure the following settings in the LASD Database panel: </p> <ul> <li>Database URL: The URL of your Aether Server instance</li> <li>Database Name: The name of your Aether Database</li> <li>Database Path: The name of the Testbed you want to export this LASD data too</li> <li>Auth Port: The authorization port for your Aether Database (Default is typically 9099)</li> <li>Database Port: The port for the Aether Database (Default is typically 9000)</li> <li>API Key: The API Key for your Aether Database</li> <li>Username: The username for your account in your Aether Database</li> <li>Password: The password for your account in your Aether Database</li> </ul> <p>Once those setting have been configured, use the <code>Export to Database</code> button to export this testbed to the Database.</p> Troubleshooting Export Errors <p>If there are errors with the export, try running the <code>Sanitize Names for Database Export</code> command, this will attempt to replace any invalid characters that cause issues when exporting (Blender .### suffix on object names is typically the culprit here)</p>"},{"location":"guide/testbed_setup/testbed_setup/#2-adding-a-testbed-plan-image","title":"2) Adding a Testbed Plan Image:","text":"<p>To add a custom background image that will display in the Aether Dashboard:</p> <ol> <li> <p>Create a plan view image plan view can be created in the tool of your testbed in the tool of your choice. The image must be saved as a .png.</p> Note <p>When creating a background image, ensure that the image is drawn using the same pixel:meter scale as defined in the testbed Metadata.</p> </li> <li> <p>Add the image to the Aether Server: plan images should be located in the <code>Testbed_Server/public/plan_images</code> folder and be named with the following format <code>[YOUR TESTBED NAME]_plan.png</code></p> </li> </ol>"},{"location":"reference/","title":"Getting Started","text":""},{"location":"reference/#project-layout","title":"Project layout","text":"<p>The testbedv4 repo is organized in three main directories</p> <pre><code>docs/             # Contains the contents of this Documentation\nNCv4_Firmware/    # The Node Controller Firmware and Web Assembly Code\nTestbed_Server/   # The web ui and nodejs control server\n</code></pre>"},{"location":"reference/documentation/","title":"Documentation","text":"<p>Documentation is located in <code>testbedv4/docs</code>.</p> <p>The Testbed v4 documentation is written in markdown, built using mkdocs and published to  Github Pages via a public repository.</p> <p>To make updates to the Testbed v4 documentation:</p> <ol> <li>Make your changes in the main testbedv4 repository.</li> <li>Commit your changes.</li> <li>Run the deployment action in the testbed-docs-temp repository.</li> </ol> For external collaborators <p>Please submit any documentation changes via pull request on the Testbed v4 repository. Repository maintainers will review the request and preform the deployment.</p>"},{"location":"reference/firmware/InfluenceEngine/","title":"Influence Engine","text":""},{"location":"reference/firmware/InfluenceEngine/#description","title":"Description","text":"<p>The <code>InfluenceEngine</code> class is an interface that all Influence Engines must implement to be registered in the firmware or web client</p>"},{"location":"reference/firmware/InfluenceEngine/#api-refrence","title":"API Refrence","text":""},{"location":"reference/firmware/InfluenceEngine/#header-file","title":"Header File","text":"<pre><code>#include \"InfluenceEngine.h\"\n</code></pre>"},{"location":"reference/firmware/InfluenceEngine/#member-functions","title":"Member Functions","text":"<p><pre><code>virtual void populateTable(table&amp; tb);\n</code></pre> Populate the passed table with parameters that will be sent through setParameters osc command</p> <p><pre><code>virtual void receiveEvent(const char* eventName, table tb, uint64_t millis);\n</code></pre> Recieve an influence engine event with arbitrary parameters stored in <code>tb</code>. Any pointers should not be stored for use after this function, so both eventName and table parameters can be freed after an event is recieved</p> <p><pre><code>virtual void update(uint64_t millis);\n</code></pre> update will be called once before any influences are calculated during a frame</p> <p><pre><code>virtual double influenceOn(int x, int y, int z, uint64_t millis);\n</code></pre> An influence that can be asked for from multiple locations during a frame and should always return a value from 0 to 1</p>"},{"location":"reference/firmware/InfluenceEngine/#member-variables","title":"Member Variables","text":"<p><pre><code>int id;\n</code></pre> Must be set to the correct constant for the implementing influence engine, as will be used for checking subscriptions</p>"},{"location":"reference/firmware/Registry/","title":"Registry","text":""},{"location":"reference/firmware/Registry/#description","title":"Description","text":"<p>A class for holding globally needed objects, to facilitate adding new influence engines and other generic modules</p>"},{"location":"reference/firmware/Registry/#api-refrence","title":"API Refrence","text":""},{"location":"reference/firmware/Registry/#header-file","title":"Header File","text":"<pre><code>#include \"Registry.h\"\n</code></pre>"},{"location":"reference/firmware/Registry/#definition","title":"Definition","text":"<pre><code>class Registry;\n</code></pre>"},{"location":"reference/firmware/Registry/#member-variables","title":"Member Variables","text":"<p><pre><code>list&lt;Actuator*&gt; actuators;\n</code></pre> growable list of actuators</p> <p><pre><code>string_map&lt;InfluenceEngine*&gt; engines;\n</code></pre> Mapping from an influence engine name to it's instance</p> <p><pre><code>string_map&lt;table&gt; tables;\n</code></pre> Mapping from an influence engine name to it's table of parameters</p>"},{"location":"reference/firmware/howtocompile/","title":"Compiling NC Firmware","text":""},{"location":"reference/firmware/howtocompile/#setting-up-the-compilation-buildchain","title":"Setting up the compilation buildchain.","text":"<ol> <li>Install Arduino-Cli</li> <li>Install Zig</li> <li>Ensure Arduino-CLI is up to date. run <code>arduino-cli update</code> and  <code>arduino-cli upgrade</code></li> <li>In the NCv4_Firmware directory run  <code>zig build arduino -Dupdate</code> to ensure required libraries are up to date</li> <li>In the NCv4_Firmware directory run  <code>zig build arduino</code> to compile the firmware. The compiled binary can be found at <code>NCv4_Firmware/build/NCv4_Firmware.ino.bin</code></li> </ol>"},{"location":"reference/firmware/howtocompile/#over-the-air-update","title":"Over The Air Update","text":"<ol> <li>Copy the binary <code>NCv4_Firmware.ino.bin</code> to <code>Testbed_Server/public/OTAbin</code></li> <li>Rename the binary to <code>NC.bin</code></li> <li>On the Testbed Dashbaord select the node controller you wish to update</li> <li>In the Hardware tab select OTA Update to send the new NC.bin to all selected NC's</li> </ol> Warning <p>For major firmware changes test the update on one NC before uploading to all NC's.</p> <p>Issues in major changes can lead to the NC being stuck in a boot loop, and in these cases working firmware will need to be reuploaded over a usb connection. Doing this for a large number of NC's is a hassle (from experience -KC)</p>"},{"location":"reference/firmware/howtocompile/#upload-over-usb","title":"Upload over USB","text":"<ol> <li>Attach the NC to your PC via USB</li> <li>in the NCv4_Firmware directory run <code>arduino-cli board list</code> to see if the NC is discovered and see it's port</li> <li>run <code>arduino-cli upload -p [PORT]</code> where [PORT] is the port shown in step 2</li> </ol>"},{"location":"reference/firmware/lib/","title":"Library","text":""},{"location":"reference/firmware/list/","title":"list","text":""},{"location":"reference/firmware/list/#description","title":"Description","text":"<p>A growable list that acts similarly to <code>std::vector</code> but only depends on the c standard library not cpp</p> <p>It can be iterated over using a for each loop, and a refrence to items can be accessed using the <code>[]</code> operator</p>"},{"location":"reference/firmware/list/#api-refrence","title":"API Refrence","text":""},{"location":"reference/firmware/list/#header-file","title":"Header File","text":"<pre><code>#include \"lib.h\"\n</code></pre>"},{"location":"reference/firmware/list/#definition","title":"Definition","text":"<pre><code>template&lt;typename T&gt; struct list;\n</code></pre>"},{"location":"reference/firmware/list/#member-functions","title":"Member functions","text":"<p><pre><code>void push(T item);\n</code></pre> Allocates if space needed for <code>item</code> and adds <code>item</code> to the end of the list.</p> <p><pre><code>T* get(int index);\n</code></pre> Returns a pointer to the item at <code>index</code>.</p> <p><pre><code>void remove(int index);\n</code></pre> Removes the item at <code>index</code> from the list and moves items down to fill in the empty space.</p> <p><pre><code>int len();\n</code></pre> Returns the amount of items in the list.</p> <p><pre><code>void free();\n</code></pre> Deallocates the internal item storage, if <code>T</code> is dynamically allocated then each item must be freed, if the list structg is dynamically allocated then the caller is responsible for freeing that memory</p>"},{"location":"reference/firmware/list/#examples","title":"Examples","text":"<pre><code>list&lt;int&gt; numbers;\nnumbers.push(12);\nnumbers.push(15);\nnumbers.push(7)\nnumbers.remove(1);\n// numbers: 12, 7\n\nbool is_true = numbers[1] == 7;\nbool is_also_true = *numbers.get(1) == 7;\n\nfor (int&amp; number : numbers) {\n  number = number*2;\n}\n// numbers: 24, 14\nnumbers[1] // 14\n</code></pre>"},{"location":"reference/firmware/option/","title":"todo","text":""},{"location":"reference/firmware/string_map/","title":"string_map","text":""},{"location":"reference/firmware/string_map/#description","title":"Description","text":"<p>A structure for associating c string(<code>const char*</code>) with a value, allowing for storage and retrieval of the value</p>"},{"location":"reference/firmware/string_map/#api-refrence","title":"API Refrence","text":""},{"location":"reference/firmware/string_map/#header-file","title":"Header File","text":"<pre><code>#include \"lib.h\"\n</code></pre>"},{"location":"reference/firmware/string_map/#definition","title":"Definition","text":"<pre><code>template&lt;typename T&gt; struct string_map;\n</code></pre>"},{"location":"reference/firmware/string_map/#member-methods","title":"Member Methods","text":"<pre><code>void add(const char *key, T item);\n</code></pre>"},{"location":"reference/firmware/table/","title":"Table","text":""},{"location":"reference/firmware/table/#todo","title":"TODO","text":""},{"location":"reference/web/coordinates/","title":"Coordinates","text":""},{"location":"reference/web/coordinates/#coordinate-spaces","title":"Coordinate Spaces","text":"<p>When writing draw functions in the Aether Dashboard. It's helpful to understand the 3 co-ordinate spaces used in dashboardP5.js</p> <ol> <li> <p>World Space: the \"Real World\" coordinates of objects</p> <ul> <li>3D Left Handed +Z Up +Y Forward (+Y up in plan view) +X Right coordinate system.</li> <li>Measured in mm.</li> <li>The origin of the World Coordinate space is typically defined by the origin point of the tool that authored the Testbed LASD data (typically the Blender or Rhino world origin).</li> </ul> </li> <li> <p>Grid Space:</p> <ul> <li>3D Left Handed +Z Up, +Y Backwards (+Y Down in plan view) +X Right coordinate system. (we don't really use the z much here, but grid space is still 3D)</li> <li>Grid space is measured in pixels,</li> <li>The Testbed background image should be centered exactly in grid space</li> <li>Origin defined by the <code>plan_offset</code> key in the testbed metadata, </li> <li>Pixel Scale (relative to world space) defined by the <code>plan_ratio</code> key in the testbed metadata ( ratio of pixels to mm )</li> <li>The maximum extents of the grid space is determined by the size of the testbed background image (in px) and our minimum zoom value.</li> </ul> </li> <li> <p>Canvas Space: this is our \"viewport\" into grid space:</p> <ul> <li>Canvas Space extents are determined by the actual canvas size on the webpage.</li> <li>Canvas Space origin is offset from grid space by the p5 grid properties <code>xoff</code> and <code>yoff</code>. (Panning)</li> <li>Scaled relative to Grid Space by the zoom value.</li> </ul> </li> </ol>"},{"location":"reference/web/coordinates/#conversion-functions","title":"Conversion Functions","text":"<p>The following conversion functions, located in dashboardP5.js can be used to convert between the Coordinate spaces:</p> <p><code>worldToGridCoords([x,y,z]) -&gt; {x:x,y:y,z:z}</code></p> <p><code>gridToWorldCoords({x:x,y:y,z:z}) -&gt; {x:x,y:y,z:z}</code></p> <p><code>canvasToGridCoords({x:x,y:y},z,p5 instance) -&gt; {x:x,y:y,z:z}</code></p> <p>Also the <code>worldMouse()</code> function on the P5 instance can be called to return the current mouse position in World Space.</p>"},{"location":"reference/web/dashboard/","title":"Dashboard","text":""},{"location":"reference/web/dashboard/#adding-new-background-images","title":"Adding new background images","text":""},{"location":"reference/web/hooks/","title":"Hooks","text":"<p>note this needs updating When creating ui with preact you probably won\u2019t work directly with state proxy subscriptions and use signals that work with state proxy there are currently four signals that are built around state-proxy and the database and they are all built upon one another.</p> <p>All these signals are built around the idea of having a state proxy object and a key where you are listening and changing the value at that key. The base signal is the dbSignal which takes a signal a state-proxy object and a key and when the value changes on the signal side updates the state which then updates the database, if the database gets updated it updates the signal value.</p> <p>The next signal is called errorSignal(name could be changed maybe to debounced) it takes a signal a state object and the key of the value to listen too, it first wraps the signal in a dbSignal, it also keeps track of if setting the signal value actually changes the database and if it doesn\u2019t then it changes the value back to the last value that was either from the database or set the database</p> <p>The third signal is a lazySignal for a signal that needs to wait for some other value like a request to firebase before it can be loaded(this value should be a signal this is undefined when loading) a lazySignal will be undefined when the signal passed to it is still loading once that value is loaded the lazy signal will act as a errorSignal where the object is a call to path with signal you are waiting on\u2019s value and the path is the string that to returns when called, and key is key</p> <p>The fourth signal is the dependentSignal similar to lazySignal we depend on another value for to derive the value of this signal and if the dependent signal is undefined we will be in a loading state and also be undefined till the dependent signal is loaded where it diverges is that after loading if the dependency changes we recompute which object to find the value on this is the getObj parameter. The idea being that the object you want to set a value at a certain key to might change based on a certain value(or values if the signal you use as a dependency is computed from multiple signals)</p>"},{"location":"reference/web/observable/","title":"Observable","text":""},{"location":"reference/web/observable/#api-refrence","title":"API Refrence","text":""},{"location":"reference/web/observable/#observableinit-path","title":"<code>observable(init, path)</code>","text":"<pre><code>import { observable } from \"/libraries/observable.js\"\nfunction observable(init, path) {\n\n}\n</code></pre>"},{"location":"reference/web/observable/#parameters","title":"Parameters","text":"Name Type Description init Object Object to add observation too, recursively wraps objects with a Proxy to ovveride the getter and setter path string Optional, if called with this parameter then all values set on this object will be synced to firebase"},{"location":"reference/web/observable/#observestate-observer-key","title":"<code>observe(state, observer, key)</code>","text":"<pre><code>import { observe } from \"/libraries/observable.js\"\nfunction observe(state, observer, key) {}\n</code></pre>"},{"location":"reference/web/observable/#parameters_1","title":"Parameters","text":"Name Type Description state observable Object to observe changes too observer <code>(state, fromDatabase, key, undoing) =&gt; void</code> function that will be called when a property of <code>state</code> changes key string Optional, if provided observer will only be called when the value of this property changes"},{"location":"reference/web/observable/#return-value","title":"Return Value","text":"<p>Function to remove the observer</p>"},{"location":"reference/web/observable/#observekeysstate-observer","title":"<code>observeKeys(state, observer)</code>","text":"<pre><code>import { observeKeys } from \"/libraries/observable.js\"\nexport function observeKeys(state, observer) {}\n</code></pre>"},{"location":"reference/web/observable/#parameters_2","title":"Parameters","text":"Name Type Description state observable Object to observe key changes too observer <code>(state, key, fromDatabase, undoing) =&gt; void</code> function that will be called when properties are added or removed from <code>state</code>"},{"location":"reference/web/observable/#return-value_1","title":"Return Value","text":"<p>Function to remove the observer</p>"},{"location":"reference/web/observable/#getstate-path-last","title":"<code>get(state, path, last)</code>","text":"<pre><code>import { get } from \"/libraries/observable.js\"\nexport function get(state, path, last) {}\n</code></pre>"},{"location":"reference/web/observable/#parameters_3","title":"Parameters","text":"Name Type Description state object path string deep path on <code>state</code> each property is delimetted by <code>.</code> for example <code>thing.colour</code> last any Optional, if provided will be used to set the last property if it is not undefined"},{"location":"reference/web/observable/#old-docs","title":"Old Docs","text":"<p>State proxy is a wrapper around a javascript object. It integrates with firebase, wrapping around a regular javascript object and tracking when things are set and get from the object.  It can also include where in firebase each object is, and automatically sync between the object and firebase. To setup up a regular proxy for subscribing to value changes or for history use you can just call <code>proxy(objName)</code> to make a proxy that wraps a firebase value you first get the object with <code>const value = await database.get(path)</code> and then create a proxy with the path <code>proxy(value, path)</code>. There a couple different things you can subscribe to, the first way to subscribe is to any changes on the database with <code>subscribe(obj, callback)</code> the second way is to if a certain key on an object changes(this key can\u2019t be another object; it should be a primitive: <code>subscribe(obj, callback, key)</code> the third way is subscribing to if a key is added or removed to an object with <code>subscribeKeys(obj, callback)</code>.</p>"},{"location":"reference/web/preact/","title":"Preact","text":"<p>See the preact docs for more info (note the preact docs use jsx in most places its quite similar to htm but uses <code>{}</code> instead of <code>${})</code></p> <p>HTM and Preact are Javascript libraries that help with creating UI components.</p> <p>To be able to have reusable components (switches, sliders, etc.) we want some way to create a function that can contain all the logic and markup to render this component.  The way we do this is with preact and htm. We use htm to create the markup, it useless a tagged template literal a template literal is just a javascript string that can include interpolations (javascript expressions within them) for example for an untagged template: <pre><code>const string = `&lt;div&gt;hello ${1}&lt;/div&gt;`\nstring == \"&lt;div&gt;hello 1&lt;/div&gt;\"\n</code></pre> the tagged template literal from htm allows us to write regular html as well as including javascript within it using the interpolations (<code>${}</code>).  The element\u2019s children and attributes that you write get passed to preact for rendering. Preact then uses that structure to create a virtual dom (vdom), a tree of the nodes and their attributes and children similar to the dom in the browser. This vdom can then be rendered within a parent element with the render function. To create a component you create a normal javascript function that takes an object with the attributes that can be set on it (sometimes called properties, or props).  This component can be included in any html template like so:  </p> <p><pre><code>html`\n&lt;${Component} attribute1=\"test\"&gt;\n  &lt;h1&gt;child element&lt;/h1&gt;\n&lt;//&gt;  \n</code></pre> Where Component is defined as: <pre><code>function Component({attribute1, children}) {\n  return html`\n    &lt;div class=${attribute1}&gt;\n      ${children}\n    &lt;/div&gt;`\n}\n</code></pre> Components functions can have other logic and such within them, and when any of their attributes/props change they cause a re-render.  This re-render only changes the vdom, not the actual webpage. Then preact will figure out what changed and then make those changes to the page https://preactjs.com/guide/v10/getting-started and the tutorial for more info</p>"},{"location":"reference/web/preact/#preact-signals","title":"Preact Signals","text":"<p>https://preactjs.com/guide/v10/signals</p>"},{"location":"reference/web/preact/#signalvalue-and-effect","title":"signal.value and effect","text":"<p>In concept a signal is just an object with a value key that signals some ui or functions when that value changes. To create a signal you use <code>const num = signal(1)</code> and then access the value with <code>num.value</code> Then one way to have a function that responds to this signal is with the effect function. The effect function runs the callback given to it and tracks which signals were accessed; when those signals values have changed, it reruns the function, the next function is computed which takes a callback to compute a new value from one or more signals and returns a readonly signal whose  value will be recomputed whenever the signals it depends on changes.</p>"},{"location":"reference/web/preact/#reactive-ui","title":"Reactive UI","text":"<p>Just like how props changing can cause preact to rerender, if signals are used in an html template it will cause preact to rerender. Signals also create another way to do a \u201cfine grained\u201d update to the ui if you pass the signal <code>object</code> instead of the <code>object.value</code> preact won\u2019t cause a rerender(calling the component function again to regenerate the virtual dom to be diffed). Some of our components take signals as attributes this allows to easily integrate with our wrapped signals for having sliders or toggles be automatically integrated with the database</p>"},{"location":"reference/web/preact/#hooks-and-wrapped-signals","title":"Hooks and wrapped signals","text":"<p>To use signals with preact, we have to use hooks. This is because we want to use the same signal on rerenders, when creating a signal from a component we use the <code>useSignal</code> function which returns the same signal on each render(under the hood it uses the useMemo hook). One common way to use signals is to wrap them to add more functionality to them; this allows for integration with the database and state proxy.</p>"},{"location":"reference/web/tailwind/","title":"Tailwind CSS","text":"<p>The css file is generated with tailwindcss and contains all the utility classes used</p>"},{"location":"reference/web/tailwind/#development","title":"Development","text":"<p>run this command and as you change classes it will update the css file <pre><code>npx tailwindcss -i ./tailwindInput.css -o ./public/tailwind.css --watch\n</code></pre></p>"}]}